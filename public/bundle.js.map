{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@hotwired/stimulus/dist/stimulus.js","webpack:///./src/controllers sync \\.js$","webpack:///./src/controllers/clipboard_controller.js","webpack:///./src/controllers/example_controller.js","webpack:///./src/controllers/menu_controller.js","webpack:///./src/index.js","webpack:///./node_modules/@hotwired/stimulus-webpack-helpers/dist/stimulus-webpack-helpers.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","EventListener","eventTarget","eventName","eventOptions","this","unorderedBindings","Set","addEventListener","removeEventListener","binding","add","delete","event","extendedEvent","stopImmediatePropagation","assign","immediatePropagationStopped","extendEvent","bindings","handleEvent","Array","from","sort","left","right","leftIndex","index","rightIndex","Dispatcher","application","eventListenerMaps","Map","started","eventListeners","forEach","eventListener","connect","disconnect","values","reduce","listeners","map","concat","fetchEventListenerForBinding","bindingConnected","bindingDisconnected","error","message","detail","handleError","fetchEventListener","eventListenerMap","fetchEventListenerMapForEventTarget","cacheKey","createEventListener","set","parts","keys","push","join","descriptorPattern","parseEventTarget","eventTargetName","window","document","camelize","replace","_","char","toUpperCase","capitalize","charAt","slice","dasherize","toLowerCase","defaultEventNames","e","getAttribute","Error","typecast","JSON","parse","o_O","Binding","context","action","identifier","willBeInvokedByEvent","invokeWithEvent","method","controller","methodName","target","currentTarget","params","actionEvent","logDebugActivity","element","Element","contains","scope","containsElement","ElementObserver","delegate","elements","mutationObserver","MutationObserver","mutations","processMutations","observe","attributes","childList","subtree","refresh","takeRecords","matches","matchElementsInTree","has","removeElement","addElement","mutation","processMutation","type","processAttributeChange","attributeName","processRemovedNodes","removedNodes","processAddedNodes","addedNodes","node","elementAttributeChanged","matchElement","nodes","elementFromNode","processTree","elementIsActive","tree","processor","nodeType","Node","ELEMENT_NODE","isConnected","elementMatched","elementUnmatched","AttributeObserver","elementObserver","start","stop","hasAttribute","match","querySelectorAll","selector","elementMatchedAttribute","elementUnmatchedAttribute","elementAttributeValueChanged","StringMapObserver","stringMap","attributeOldValue","knownAttributeNames","refreshAttribute","oldValue","getStringMapKeyForAttribute","stringMapKeyAdded","stringMapValueChanged","stringMapKeyRemoved","currentAttributeNames","recordedAttributeNames","attribute","fetch","del","size","prune","Multimap","valuesByKey","some","filter","TokenListObserver","attributeObserver","tokensByElement","tokensMatched","readTokensForElement","unmatchedTokens","matchedTokens","refreshTokensForElement","tokensUnmatched","getValuesForKey","tokens","token","tokenMatched","tokenUnmatched","previousTokens","currentTokens","firstDifferingIndex","length","Math","max","zip","findIndex","previousToken","currentToken","content","tokenString","trim","split","parseTokenString","ValueListObserver","tokenListObserver","parseResultsByToken","WeakMap","valuesByTokenByElement","fetchParseResultForToken","fetchValuesByTokenForElement","elementMatchedValue","elementUnmatchedValue","parseResult","parseToken","valuesByToken","parseValueForToken","BindingObserver","bindingsByAction","valueListObserver","actionAttribute","disconnectAllActions","schema","clear","descriptor","tagName","getDefaultEventNameForElement","descriptorString","options","test","parseActionDescriptorString","eventNameSuffix","getParamsFromEventTargetAttributes","pattern","RegExp","forToken","connectAction","disconnectAction","ValueObserver","receiver","stringMapObserver","valueDescriptorMap","invokeChangedCallbacksForDefaultValues","hasValue","invokeChangedCallback","writer","defaultValue","valueDescriptorNameMap","valueDescriptors","undefined","data","rawValue","rawOldValue","changedMethodName","changedMethod","reader","descriptors","hasMethodName","TargetObserver","targetsByName","disconnectAllTargets","connectTarget","disconnectTarget","targetConnected","targetDisconnected","Context","functionName","controllerConstructor","bindingObserver","dispatcher","valueObserver","targetObserver","initialize","parentElement","invokeControllerMethod","args","readInheritableStaticArrayValues","constructor","propertyName","ancestors","getAncestorsForConstructor","definition","isArray","getOwnStaticArrayValues","readInheritableStaticObjectPairs","pairs","getOwnStaticObjectPairs","getPrototypeOf","reverse","bless","properties","shadowConstructor","extend","shadowProperties","getOwnKeys","shadowingDescriptor","getOwnPropertyDescriptor","getShadowedDescriptor","getShadowProperties","defineProperties","shadow","blessedProperties","blessing","getBlessedProperties","getOwnPropertySymbols","getOwnPropertyNames","extendWithReflect","extended","Reflect","construct","arguments","setPrototypeOf","b","a","testReflectExtension","Module","blessDefinition","contextsByScope","connectedContexts","fetchContextForScope","ClassMap","getDataKey","getAll","getAttributeNameForKey","DataMap","setAttribute","removeAttribute","Guide","logger","warnedKeysByObject","warnedKeys","warn","attributeValueContainsToken","TargetSet","targetName","find","targetNames","findTarget","findLegacyTarget","targets","findAllTargets","findAllLegacyTargets","getSelectorForTargetName","findElement","findAllElements","targetAttributeForScope","getLegacySelectorForTargetName","deprecate","targetDescriptor","targetAttribute","revisedAttributeName","guide","Scope","classes","closest","controllerSelector","queryElements","controllerAttribute","ScopeObserver","scopesByIdentifierByElement","scopeReferenceCounts","scopesByIdentifier","fetchScopesByIdentifierForElement","createScopeForElementAndIdentifier","referenceCount","scopeConnected","scopeDisconnected","Router","scopeObserver","modulesByIdentifier","contexts","unloadIdentifier","connectModule","disconnectModule","connectContextForScope","disconnectContextForScope","defaultSchema","Application","documentElement","console","debug","logFormattedMessage","router","Promise","resolve","readyState","shouldLoad","load","head","rest","loadDefinition","getContextForElementAndIdentifier","_a","onerror","groupCollapsed","log","groupEnd","parseValueDefinitionPair","typeDefinition","typeFromObject","typeObject","parseValueTypeConstant","defaultValueType","parseValueTypeDefault","default","parseValueTypeObject","typeFromDefaultValue","typeFromConstant","parseValueTypeDefinition","constant","defaultValuesByType","defaultValueForDefinition","readers","writers","valueDescriptorForTokenAndTypeDefinition","Boolean","Number","String","toString","boolean","number","string","array","TypeError","writeJSON","stringify","Controller","prefix","bubbles","cancelable","CustomEvent","dispatchEvent","blessings","classDefinition","getAttributeName","targetDefinition","findAll","valueDefinitionPairs","propertyDescriptorMap","result","valueDefinitionPair","valueDescriptor","read","write","hasCustomDefaultValue","propertiesForValueDefinitionPair","webpackContext","req","id","webpackContextResolve","code","copy","navigator","clipboard","writeText","sourceTarget","textContent","toggle","toggleableTarget","classList","require","logicalName","identifierForContextKey","definitionForModuleAndIdentifier","definitionForModuleWithContextAndKey","definitionsFromContext"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","/*\nStimulus 3.0.0\nCopyright Â© 2021 Basecamp, LLC\n */\nclass EventListener {\n    constructor(eventTarget, eventName, eventOptions) {\n        this.eventTarget = eventTarget;\n        this.eventName = eventName;\n        this.eventOptions = eventOptions;\n        this.unorderedBindings = new Set();\n    }\n    connect() {\n        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);\n    }\n    disconnect() {\n        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);\n    }\n    bindingConnected(binding) {\n        this.unorderedBindings.add(binding);\n    }\n    bindingDisconnected(binding) {\n        this.unorderedBindings.delete(binding);\n    }\n    handleEvent(event) {\n        const extendedEvent = extendEvent(event);\n        for (const binding of this.bindings) {\n            if (extendedEvent.immediatePropagationStopped) {\n                break;\n            }\n            else {\n                binding.handleEvent(extendedEvent);\n            }\n        }\n    }\n    get bindings() {\n        return Array.from(this.unorderedBindings).sort((left, right) => {\n            const leftIndex = left.index, rightIndex = right.index;\n            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;\n        });\n    }\n}\nfunction extendEvent(event) {\n    if (\"immediatePropagationStopped\" in event) {\n        return event;\n    }\n    else {\n        const { stopImmediatePropagation } = event;\n        return Object.assign(event, {\n            immediatePropagationStopped: false,\n            stopImmediatePropagation() {\n                this.immediatePropagationStopped = true;\n                stopImmediatePropagation.call(this);\n            }\n        });\n    }\n}\n\nclass Dispatcher {\n    constructor(application) {\n        this.application = application;\n        this.eventListenerMaps = new Map;\n        this.started = false;\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.eventListeners.forEach(eventListener => eventListener.connect());\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.started = false;\n            this.eventListeners.forEach(eventListener => eventListener.disconnect());\n        }\n    }\n    get eventListeners() {\n        return Array.from(this.eventListenerMaps.values())\n            .reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);\n    }\n    bindingConnected(binding) {\n        this.fetchEventListenerForBinding(binding).bindingConnected(binding);\n    }\n    bindingDisconnected(binding) {\n        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);\n    }\n    handleError(error, message, detail = {}) {\n        this.application.handleError(error, `Error ${message}`, detail);\n    }\n    fetchEventListenerForBinding(binding) {\n        const { eventTarget, eventName, eventOptions } = binding;\n        return this.fetchEventListener(eventTarget, eventName, eventOptions);\n    }\n    fetchEventListener(eventTarget, eventName, eventOptions) {\n        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);\n        const cacheKey = this.cacheKey(eventName, eventOptions);\n        let eventListener = eventListenerMap.get(cacheKey);\n        if (!eventListener) {\n            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);\n            eventListenerMap.set(cacheKey, eventListener);\n        }\n        return eventListener;\n    }\n    createEventListener(eventTarget, eventName, eventOptions) {\n        const eventListener = new EventListener(eventTarget, eventName, eventOptions);\n        if (this.started) {\n            eventListener.connect();\n        }\n        return eventListener;\n    }\n    fetchEventListenerMapForEventTarget(eventTarget) {\n        let eventListenerMap = this.eventListenerMaps.get(eventTarget);\n        if (!eventListenerMap) {\n            eventListenerMap = new Map;\n            this.eventListenerMaps.set(eventTarget, eventListenerMap);\n        }\n        return eventListenerMap;\n    }\n    cacheKey(eventName, eventOptions) {\n        const parts = [eventName];\n        Object.keys(eventOptions).sort().forEach(key => {\n            parts.push(`${eventOptions[key] ? \"\" : \"!\"}${key}`);\n        });\n        return parts.join(\":\");\n    }\n}\n\nconst descriptorPattern = /^((.+?)(@(window|document))?->)?(.+?)(#([^:]+?))(:(.+))?$/;\nfunction parseActionDescriptorString(descriptorString) {\n    const source = descriptorString.trim();\n    const matches = source.match(descriptorPattern) || [];\n    return {\n        eventTarget: parseEventTarget(matches[4]),\n        eventName: matches[2],\n        eventOptions: matches[9] ? parseEventOptions(matches[9]) : {},\n        identifier: matches[5],\n        methodName: matches[7]\n    };\n}\nfunction parseEventTarget(eventTargetName) {\n    if (eventTargetName == \"window\") {\n        return window;\n    }\n    else if (eventTargetName == \"document\") {\n        return document;\n    }\n}\nfunction parseEventOptions(eventOptions) {\n    return eventOptions.split(\":\").reduce((options, token) => Object.assign(options, { [token.replace(/^!/, \"\")]: !/^!/.test(token) }), {});\n}\nfunction stringifyEventTarget(eventTarget) {\n    if (eventTarget == window) {\n        return \"window\";\n    }\n    else if (eventTarget == document) {\n        return \"document\";\n    }\n}\n\nfunction camelize(value) {\n    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());\n}\nfunction capitalize(value) {\n    return value.charAt(0).toUpperCase() + value.slice(1);\n}\nfunction dasherize(value) {\n    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);\n}\nfunction tokenize(value) {\n    return value.match(/[^\\s]+/g) || [];\n}\n\nclass Action {\n    constructor(element, index, descriptor) {\n        this.element = element;\n        this.index = index;\n        this.eventTarget = descriptor.eventTarget || element;\n        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error(\"missing event name\");\n        this.eventOptions = descriptor.eventOptions || {};\n        this.identifier = descriptor.identifier || error(\"missing identifier\");\n        this.methodName = descriptor.methodName || error(\"missing method name\");\n    }\n    static forToken(token) {\n        return new this(token.element, token.index, parseActionDescriptorString(token.content));\n    }\n    toString() {\n        const eventNameSuffix = this.eventTargetName ? `@${this.eventTargetName}` : \"\";\n        return `${this.eventName}${eventNameSuffix}->${this.identifier}#${this.methodName}`;\n    }\n    get params() {\n        if (this.eventTarget instanceof Element) {\n            return this.getParamsFromEventTargetAttributes(this.eventTarget);\n        }\n        else {\n            return {};\n        }\n    }\n    getParamsFromEventTargetAttributes(eventTarget) {\n        const params = {};\n        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`);\n        const attributes = Array.from(eventTarget.attributes);\n        attributes.forEach(({ name, value }) => {\n            const match = name.match(pattern);\n            const key = match && match[1];\n            if (key) {\n                Object.assign(params, { [camelize(key)]: typecast(value) });\n            }\n        });\n        return params;\n    }\n    get eventTargetName() {\n        return stringifyEventTarget(this.eventTarget);\n    }\n}\nconst defaultEventNames = {\n    \"a\": e => \"click\",\n    \"button\": e => \"click\",\n    \"form\": e => \"submit\",\n    \"input\": e => e.getAttribute(\"type\") == \"submit\" ? \"click\" : \"input\",\n    \"select\": e => \"change\",\n    \"textarea\": e => \"input\"\n};\nfunction getDefaultEventNameForElement(element) {\n    const tagName = element.tagName.toLowerCase();\n    if (tagName in defaultEventNames) {\n        return defaultEventNames[tagName](element);\n    }\n}\nfunction error(message) {\n    throw new Error(message);\n}\nfunction typecast(value) {\n    try {\n        return JSON.parse(value);\n    }\n    catch (o_O) {\n        return value;\n    }\n}\n\nclass Binding {\n    constructor(context, action) {\n        this.context = context;\n        this.action = action;\n    }\n    get index() {\n        return this.action.index;\n    }\n    get eventTarget() {\n        return this.action.eventTarget;\n    }\n    get eventOptions() {\n        return this.action.eventOptions;\n    }\n    get identifier() {\n        return this.context.identifier;\n    }\n    handleEvent(event) {\n        if (this.willBeInvokedByEvent(event)) {\n            this.invokeWithEvent(event);\n        }\n    }\n    get eventName() {\n        return this.action.eventName;\n    }\n    get method() {\n        const method = this.controller[this.methodName];\n        if (typeof method == \"function\") {\n            return method;\n        }\n        throw new Error(`Action \"${this.action}\" references undefined method \"${this.methodName}\"`);\n    }\n    invokeWithEvent(event) {\n        const { target, currentTarget } = event;\n        try {\n            const { params } = this.action;\n            const actionEvent = Object.assign(event, { params });\n            this.method.call(this.controller, actionEvent);\n            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });\n        }\n        catch (error) {\n            const { identifier, controller, element, index } = this;\n            const detail = { identifier, controller, element, index, event };\n            this.context.handleError(error, `invoking action \"${this.action}\"`, detail);\n        }\n    }\n    willBeInvokedByEvent(event) {\n        const eventTarget = event.target;\n        if (this.element === eventTarget) {\n            return true;\n        }\n        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {\n            return this.scope.containsElement(eventTarget);\n        }\n        else {\n            return this.scope.containsElement(this.action.element);\n        }\n    }\n    get controller() {\n        return this.context.controller;\n    }\n    get methodName() {\n        return this.action.methodName;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n}\n\nclass ElementObserver {\n    constructor(element, delegate) {\n        this.element = element;\n        this.started = false;\n        this.delegate = delegate;\n        this.elements = new Set;\n        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, { attributes: true, childList: true, subtree: true });\n            this.refresh();\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    }\n    refresh() {\n        if (this.started) {\n            const matches = new Set(this.matchElementsInTree());\n            for (const element of Array.from(this.elements)) {\n                if (!matches.has(element)) {\n                    this.removeElement(element);\n                }\n            }\n            for (const element of Array.from(matches)) {\n                this.addElement(element);\n            }\n        }\n    }\n    processMutations(mutations) {\n        if (this.started) {\n            for (const mutation of mutations) {\n                this.processMutation(mutation);\n            }\n        }\n    }\n    processMutation(mutation) {\n        if (mutation.type == \"attributes\") {\n            this.processAttributeChange(mutation.target, mutation.attributeName);\n        }\n        else if (mutation.type == \"childList\") {\n            this.processRemovedNodes(mutation.removedNodes);\n            this.processAddedNodes(mutation.addedNodes);\n        }\n    }\n    processAttributeChange(node, attributeName) {\n        const element = node;\n        if (this.elements.has(element)) {\n            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {\n                this.delegate.elementAttributeChanged(element, attributeName);\n            }\n            else {\n                this.removeElement(element);\n            }\n        }\n        else if (this.matchElement(element)) {\n            this.addElement(element);\n        }\n    }\n    processRemovedNodes(nodes) {\n        for (const node of Array.from(nodes)) {\n            const element = this.elementFromNode(node);\n            if (element) {\n                this.processTree(element, this.removeElement);\n            }\n        }\n    }\n    processAddedNodes(nodes) {\n        for (const node of Array.from(nodes)) {\n            const element = this.elementFromNode(node);\n            if (element && this.elementIsActive(element)) {\n                this.processTree(element, this.addElement);\n            }\n        }\n    }\n    matchElement(element) {\n        return this.delegate.matchElement(element);\n    }\n    matchElementsInTree(tree = this.element) {\n        return this.delegate.matchElementsInTree(tree);\n    }\n    processTree(tree, processor) {\n        for (const element of this.matchElementsInTree(tree)) {\n            processor.call(this, element);\n        }\n    }\n    elementFromNode(node) {\n        if (node.nodeType == Node.ELEMENT_NODE) {\n            return node;\n        }\n    }\n    elementIsActive(element) {\n        if (element.isConnected != this.element.isConnected) {\n            return false;\n        }\n        else {\n            return this.element.contains(element);\n        }\n    }\n    addElement(element) {\n        if (!this.elements.has(element)) {\n            if (this.elementIsActive(element)) {\n                this.elements.add(element);\n                if (this.delegate.elementMatched) {\n                    this.delegate.elementMatched(element);\n                }\n            }\n        }\n    }\n    removeElement(element) {\n        if (this.elements.has(element)) {\n            this.elements.delete(element);\n            if (this.delegate.elementUnmatched) {\n                this.delegate.elementUnmatched(element);\n            }\n        }\n    }\n}\n\nclass AttributeObserver {\n    constructor(element, attributeName, delegate) {\n        this.attributeName = attributeName;\n        this.delegate = delegate;\n        this.elementObserver = new ElementObserver(element, this);\n    }\n    get element() {\n        return this.elementObserver.element;\n    }\n    get selector() {\n        return `[${this.attributeName}]`;\n    }\n    start() {\n        this.elementObserver.start();\n    }\n    stop() {\n        this.elementObserver.stop();\n    }\n    refresh() {\n        this.elementObserver.refresh();\n    }\n    get started() {\n        return this.elementObserver.started;\n    }\n    matchElement(element) {\n        return element.hasAttribute(this.attributeName);\n    }\n    matchElementsInTree(tree) {\n        const match = this.matchElement(tree) ? [tree] : [];\n        const matches = Array.from(tree.querySelectorAll(this.selector));\n        return match.concat(matches);\n    }\n    elementMatched(element) {\n        if (this.delegate.elementMatchedAttribute) {\n            this.delegate.elementMatchedAttribute(element, this.attributeName);\n        }\n    }\n    elementUnmatched(element) {\n        if (this.delegate.elementUnmatchedAttribute) {\n            this.delegate.elementUnmatchedAttribute(element, this.attributeName);\n        }\n    }\n    elementAttributeChanged(element, attributeName) {\n        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {\n            this.delegate.elementAttributeValueChanged(element, attributeName);\n        }\n    }\n}\n\nclass StringMapObserver {\n    constructor(element, delegate) {\n        this.element = element;\n        this.delegate = delegate;\n        this.started = false;\n        this.stringMap = new Map;\n        this.mutationObserver = new MutationObserver(mutations => this.processMutations(mutations));\n    }\n    start() {\n        if (!this.started) {\n            this.started = true;\n            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });\n            this.refresh();\n        }\n    }\n    stop() {\n        if (this.started) {\n            this.mutationObserver.takeRecords();\n            this.mutationObserver.disconnect();\n            this.started = false;\n        }\n    }\n    refresh() {\n        if (this.started) {\n            for (const attributeName of this.knownAttributeNames) {\n                this.refreshAttribute(attributeName, null);\n            }\n        }\n    }\n    processMutations(mutations) {\n        if (this.started) {\n            for (const mutation of mutations) {\n                this.processMutation(mutation);\n            }\n        }\n    }\n    processMutation(mutation) {\n        const attributeName = mutation.attributeName;\n        if (attributeName) {\n            this.refreshAttribute(attributeName, mutation.oldValue);\n        }\n    }\n    refreshAttribute(attributeName, oldValue) {\n        const key = this.delegate.getStringMapKeyForAttribute(attributeName);\n        if (key != null) {\n            if (!this.stringMap.has(attributeName)) {\n                this.stringMapKeyAdded(key, attributeName);\n            }\n            const value = this.element.getAttribute(attributeName);\n            if (this.stringMap.get(attributeName) != value) {\n                this.stringMapValueChanged(value, key, oldValue);\n            }\n            if (value == null) {\n                const oldValue = this.stringMap.get(attributeName);\n                this.stringMap.delete(attributeName);\n                if (oldValue)\n                    this.stringMapKeyRemoved(key, attributeName, oldValue);\n            }\n            else {\n                this.stringMap.set(attributeName, value);\n            }\n        }\n    }\n    stringMapKeyAdded(key, attributeName) {\n        if (this.delegate.stringMapKeyAdded) {\n            this.delegate.stringMapKeyAdded(key, attributeName);\n        }\n    }\n    stringMapValueChanged(value, key, oldValue) {\n        if (this.delegate.stringMapValueChanged) {\n            this.delegate.stringMapValueChanged(value, key, oldValue);\n        }\n    }\n    stringMapKeyRemoved(key, attributeName, oldValue) {\n        if (this.delegate.stringMapKeyRemoved) {\n            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);\n        }\n    }\n    get knownAttributeNames() {\n        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));\n    }\n    get currentAttributeNames() {\n        return Array.from(this.element.attributes).map(attribute => attribute.name);\n    }\n    get recordedAttributeNames() {\n        return Array.from(this.stringMap.keys());\n    }\n}\n\nfunction add(map, key, value) {\n    fetch(map, key).add(value);\n}\nfunction del(map, key, value) {\n    fetch(map, key).delete(value);\n    prune(map, key);\n}\nfunction fetch(map, key) {\n    let values = map.get(key);\n    if (!values) {\n        values = new Set();\n        map.set(key, values);\n    }\n    return values;\n}\nfunction prune(map, key) {\n    const values = map.get(key);\n    if (values != null && values.size == 0) {\n        map.delete(key);\n    }\n}\n\nclass Multimap {\n    constructor() {\n        this.valuesByKey = new Map();\n    }\n    get keys() {\n        return Array.from(this.valuesByKey.keys());\n    }\n    get values() {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.reduce((values, set) => values.concat(Array.from(set)), []);\n    }\n    get size() {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.reduce((size, set) => size + set.size, 0);\n    }\n    add(key, value) {\n        add(this.valuesByKey, key, value);\n    }\n    delete(key, value) {\n        del(this.valuesByKey, key, value);\n    }\n    has(key, value) {\n        const values = this.valuesByKey.get(key);\n        return values != null && values.has(value);\n    }\n    hasKey(key) {\n        return this.valuesByKey.has(key);\n    }\n    hasValue(value) {\n        const sets = Array.from(this.valuesByKey.values());\n        return sets.some(set => set.has(value));\n    }\n    getValuesForKey(key) {\n        const values = this.valuesByKey.get(key);\n        return values ? Array.from(values) : [];\n    }\n    getKeysForValue(value) {\n        return Array.from(this.valuesByKey)\n            .filter(([key, values]) => values.has(value))\n            .map(([key, values]) => key);\n    }\n}\n\nclass IndexedMultimap extends Multimap {\n    constructor() {\n        super();\n        this.keysByValue = new Map;\n    }\n    get values() {\n        return Array.from(this.keysByValue.keys());\n    }\n    add(key, value) {\n        super.add(key, value);\n        add(this.keysByValue, value, key);\n    }\n    delete(key, value) {\n        super.delete(key, value);\n        del(this.keysByValue, value, key);\n    }\n    hasValue(value) {\n        return this.keysByValue.has(value);\n    }\n    getKeysForValue(value) {\n        const set = this.keysByValue.get(value);\n        return set ? Array.from(set) : [];\n    }\n}\n\nclass TokenListObserver {\n    constructor(element, attributeName, delegate) {\n        this.attributeObserver = new AttributeObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.tokensByElement = new Multimap;\n    }\n    get started() {\n        return this.attributeObserver.started;\n    }\n    start() {\n        this.attributeObserver.start();\n    }\n    stop() {\n        this.attributeObserver.stop();\n    }\n    refresh() {\n        this.attributeObserver.refresh();\n    }\n    get element() {\n        return this.attributeObserver.element;\n    }\n    get attributeName() {\n        return this.attributeObserver.attributeName;\n    }\n    elementMatchedAttribute(element) {\n        this.tokensMatched(this.readTokensForElement(element));\n    }\n    elementAttributeValueChanged(element) {\n        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);\n        this.tokensUnmatched(unmatchedTokens);\n        this.tokensMatched(matchedTokens);\n    }\n    elementUnmatchedAttribute(element) {\n        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));\n    }\n    tokensMatched(tokens) {\n        tokens.forEach(token => this.tokenMatched(token));\n    }\n    tokensUnmatched(tokens) {\n        tokens.forEach(token => this.tokenUnmatched(token));\n    }\n    tokenMatched(token) {\n        this.delegate.tokenMatched(token);\n        this.tokensByElement.add(token.element, token);\n    }\n    tokenUnmatched(token) {\n        this.delegate.tokenUnmatched(token);\n        this.tokensByElement.delete(token.element, token);\n    }\n    refreshTokensForElement(element) {\n        const previousTokens = this.tokensByElement.getValuesForKey(element);\n        const currentTokens = this.readTokensForElement(element);\n        const firstDifferingIndex = zip(previousTokens, currentTokens)\n            .findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));\n        if (firstDifferingIndex == -1) {\n            return [[], []];\n        }\n        else {\n            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];\n        }\n    }\n    readTokensForElement(element) {\n        const attributeName = this.attributeName;\n        const tokenString = element.getAttribute(attributeName) || \"\";\n        return parseTokenString(tokenString, element, attributeName);\n    }\n}\nfunction parseTokenString(tokenString, element, attributeName) {\n    return tokenString.trim().split(/\\s+/).filter(content => content.length)\n        .map((content, index) => ({ element, attributeName, content, index }));\n}\nfunction zip(left, right) {\n    const length = Math.max(left.length, right.length);\n    return Array.from({ length }, (_, index) => [left[index], right[index]]);\n}\nfunction tokensAreEqual(left, right) {\n    return left && right && left.index == right.index && left.content == right.content;\n}\n\nclass ValueListObserver {\n    constructor(element, attributeName, delegate) {\n        this.tokenListObserver = new TokenListObserver(element, attributeName, this);\n        this.delegate = delegate;\n        this.parseResultsByToken = new WeakMap;\n        this.valuesByTokenByElement = new WeakMap;\n    }\n    get started() {\n        return this.tokenListObserver.started;\n    }\n    start() {\n        this.tokenListObserver.start();\n    }\n    stop() {\n        this.tokenListObserver.stop();\n    }\n    refresh() {\n        this.tokenListObserver.refresh();\n    }\n    get element() {\n        return this.tokenListObserver.element;\n    }\n    get attributeName() {\n        return this.tokenListObserver.attributeName;\n    }\n    tokenMatched(token) {\n        const { element } = token;\n        const { value } = this.fetchParseResultForToken(token);\n        if (value) {\n            this.fetchValuesByTokenForElement(element).set(token, value);\n            this.delegate.elementMatchedValue(element, value);\n        }\n    }\n    tokenUnmatched(token) {\n        const { element } = token;\n        const { value } = this.fetchParseResultForToken(token);\n        if (value) {\n            this.fetchValuesByTokenForElement(element).delete(token);\n            this.delegate.elementUnmatchedValue(element, value);\n        }\n    }\n    fetchParseResultForToken(token) {\n        let parseResult = this.parseResultsByToken.get(token);\n        if (!parseResult) {\n            parseResult = this.parseToken(token);\n            this.parseResultsByToken.set(token, parseResult);\n        }\n        return parseResult;\n    }\n    fetchValuesByTokenForElement(element) {\n        let valuesByToken = this.valuesByTokenByElement.get(element);\n        if (!valuesByToken) {\n            valuesByToken = new Map;\n            this.valuesByTokenByElement.set(element, valuesByToken);\n        }\n        return valuesByToken;\n    }\n    parseToken(token) {\n        try {\n            const value = this.delegate.parseValueForToken(token);\n            return { value };\n        }\n        catch (error) {\n            return { error };\n        }\n    }\n}\n\nclass BindingObserver {\n    constructor(context, delegate) {\n        this.context = context;\n        this.delegate = delegate;\n        this.bindingsByAction = new Map;\n    }\n    start() {\n        if (!this.valueListObserver) {\n            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);\n            this.valueListObserver.start();\n        }\n    }\n    stop() {\n        if (this.valueListObserver) {\n            this.valueListObserver.stop();\n            delete this.valueListObserver;\n            this.disconnectAllActions();\n        }\n    }\n    get element() {\n        return this.context.element;\n    }\n    get identifier() {\n        return this.context.identifier;\n    }\n    get actionAttribute() {\n        return this.schema.actionAttribute;\n    }\n    get schema() {\n        return this.context.schema;\n    }\n    get bindings() {\n        return Array.from(this.bindingsByAction.values());\n    }\n    connectAction(action) {\n        const binding = new Binding(this.context, action);\n        this.bindingsByAction.set(action, binding);\n        this.delegate.bindingConnected(binding);\n    }\n    disconnectAction(action) {\n        const binding = this.bindingsByAction.get(action);\n        if (binding) {\n            this.bindingsByAction.delete(action);\n            this.delegate.bindingDisconnected(binding);\n        }\n    }\n    disconnectAllActions() {\n        this.bindings.forEach(binding => this.delegate.bindingDisconnected(binding));\n        this.bindingsByAction.clear();\n    }\n    parseValueForToken(token) {\n        const action = Action.forToken(token);\n        if (action.identifier == this.identifier) {\n            return action;\n        }\n    }\n    elementMatchedValue(element, action) {\n        this.connectAction(action);\n    }\n    elementUnmatchedValue(element, action) {\n        this.disconnectAction(action);\n    }\n}\n\nclass ValueObserver {\n    constructor(context, receiver) {\n        this.context = context;\n        this.receiver = receiver;\n        this.stringMapObserver = new StringMapObserver(this.element, this);\n        this.valueDescriptorMap = this.controller.valueDescriptorMap;\n        this.invokeChangedCallbacksForDefaultValues();\n    }\n    start() {\n        this.stringMapObserver.start();\n    }\n    stop() {\n        this.stringMapObserver.stop();\n    }\n    get element() {\n        return this.context.element;\n    }\n    get controller() {\n        return this.context.controller;\n    }\n    getStringMapKeyForAttribute(attributeName) {\n        if (attributeName in this.valueDescriptorMap) {\n            return this.valueDescriptorMap[attributeName].name;\n        }\n    }\n    stringMapKeyAdded(key, attributeName) {\n        const descriptor = this.valueDescriptorMap[attributeName];\n        if (!this.hasValue(key)) {\n            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));\n        }\n    }\n    stringMapValueChanged(value, name, oldValue) {\n        const descriptor = this.valueDescriptorNameMap[name];\n        if (value === null)\n            return;\n        if (oldValue === null) {\n            oldValue = descriptor.writer(descriptor.defaultValue);\n        }\n        this.invokeChangedCallback(name, value, oldValue);\n    }\n    stringMapKeyRemoved(key, attributeName, oldValue) {\n        const descriptor = this.valueDescriptorNameMap[key];\n        if (this.hasValue(key)) {\n            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);\n        }\n        else {\n            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);\n        }\n    }\n    invokeChangedCallbacksForDefaultValues() {\n        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {\n            if (defaultValue != undefined && !this.controller.data.has(key)) {\n                this.invokeChangedCallback(name, writer(defaultValue), undefined);\n            }\n        }\n    }\n    invokeChangedCallback(name, rawValue, rawOldValue) {\n        const changedMethodName = `${name}Changed`;\n        const changedMethod = this.receiver[changedMethodName];\n        if (typeof changedMethod == \"function\") {\n            const descriptor = this.valueDescriptorNameMap[name];\n            const value = descriptor.reader(rawValue);\n            let oldValue = rawOldValue;\n            if (rawOldValue) {\n                oldValue = descriptor.reader(rawOldValue);\n            }\n            changedMethod.call(this.receiver, value, oldValue);\n        }\n    }\n    get valueDescriptors() {\n        const { valueDescriptorMap } = this;\n        return Object.keys(valueDescriptorMap).map(key => valueDescriptorMap[key]);\n    }\n    get valueDescriptorNameMap() {\n        const descriptors = {};\n        Object.keys(this.valueDescriptorMap).forEach(key => {\n            const descriptor = this.valueDescriptorMap[key];\n            descriptors[descriptor.name] = descriptor;\n        });\n        return descriptors;\n    }\n    hasValue(attributeName) {\n        const descriptor = this.valueDescriptorNameMap[attributeName];\n        const hasMethodName = `has${capitalize(descriptor.name)}`;\n        return this.receiver[hasMethodName];\n    }\n}\n\nclass TargetObserver {\n    constructor(context, delegate) {\n        this.context = context;\n        this.delegate = delegate;\n        this.targetsByName = new Multimap;\n    }\n    start() {\n        if (!this.tokenListObserver) {\n            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);\n            this.tokenListObserver.start();\n        }\n    }\n    stop() {\n        if (this.tokenListObserver) {\n            this.disconnectAllTargets();\n            this.tokenListObserver.stop();\n            delete this.tokenListObserver;\n        }\n    }\n    tokenMatched({ element, content: name }) {\n        if (this.scope.containsElement(element)) {\n            this.connectTarget(element, name);\n        }\n    }\n    tokenUnmatched({ element, content: name }) {\n        this.disconnectTarget(element, name);\n    }\n    connectTarget(element, name) {\n        if (!this.targetsByName.has(name, element)) {\n            this.targetsByName.add(name, element);\n            this.delegate.targetConnected(element, name);\n        }\n    }\n    disconnectTarget(element, name) {\n        if (this.targetsByName.has(name, element)) {\n            this.targetsByName.delete(name, element);\n            this.delegate.targetDisconnected(element, name);\n        }\n    }\n    disconnectAllTargets() {\n        for (const name of this.targetsByName.keys) {\n            for (const element of this.targetsByName.getValuesForKey(name)) {\n                this.disconnectTarget(element, name);\n            }\n        }\n    }\n    get attributeName() {\n        return `data-${this.context.identifier}-target`;\n    }\n    get element() {\n        return this.context.element;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n}\n\nclass Context {\n    constructor(module, scope) {\n        this.logDebugActivity = (functionName, detail = {}) => {\n            const { identifier, controller, element } = this;\n            detail = Object.assign({ identifier, controller, element }, detail);\n            this.application.logDebugActivity(this.identifier, functionName, detail);\n        };\n        this.module = module;\n        this.scope = scope;\n        this.controller = new module.controllerConstructor(this);\n        this.bindingObserver = new BindingObserver(this, this.dispatcher);\n        this.valueObserver = new ValueObserver(this, this.controller);\n        this.targetObserver = new TargetObserver(this, this);\n        try {\n            this.controller.initialize();\n            this.logDebugActivity(\"initialize\");\n        }\n        catch (error) {\n            this.handleError(error, \"initializing controller\");\n        }\n    }\n    connect() {\n        this.bindingObserver.start();\n        this.valueObserver.start();\n        this.targetObserver.start();\n        try {\n            this.controller.connect();\n            this.logDebugActivity(\"connect\");\n        }\n        catch (error) {\n            this.handleError(error, \"connecting controller\");\n        }\n    }\n    disconnect() {\n        try {\n            this.controller.disconnect();\n            this.logDebugActivity(\"disconnect\");\n        }\n        catch (error) {\n            this.handleError(error, \"disconnecting controller\");\n        }\n        this.targetObserver.stop();\n        this.valueObserver.stop();\n        this.bindingObserver.stop();\n    }\n    get application() {\n        return this.module.application;\n    }\n    get identifier() {\n        return this.module.identifier;\n    }\n    get schema() {\n        return this.application.schema;\n    }\n    get dispatcher() {\n        return this.application.dispatcher;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get parentElement() {\n        return this.element.parentElement;\n    }\n    handleError(error, message, detail = {}) {\n        const { identifier, controller, element } = this;\n        detail = Object.assign({ identifier, controller, element }, detail);\n        this.application.handleError(error, `Error ${message}`, detail);\n    }\n    targetConnected(element, name) {\n        this.invokeControllerMethod(`${name}TargetConnected`, element);\n    }\n    targetDisconnected(element, name) {\n        this.invokeControllerMethod(`${name}TargetDisconnected`, element);\n    }\n    invokeControllerMethod(methodName, ...args) {\n        const controller = this.controller;\n        if (typeof controller[methodName] == \"function\") {\n            controller[methodName](...args);\n        }\n    }\n}\n\nfunction readInheritableStaticArrayValues(constructor, propertyName) {\n    const ancestors = getAncestorsForConstructor(constructor);\n    return Array.from(ancestors.reduce((values, constructor) => {\n        getOwnStaticArrayValues(constructor, propertyName).forEach(name => values.add(name));\n        return values;\n    }, new Set));\n}\nfunction readInheritableStaticObjectPairs(constructor, propertyName) {\n    const ancestors = getAncestorsForConstructor(constructor);\n    return ancestors.reduce((pairs, constructor) => {\n        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));\n        return pairs;\n    }, []);\n}\nfunction getAncestorsForConstructor(constructor) {\n    const ancestors = [];\n    while (constructor) {\n        ancestors.push(constructor);\n        constructor = Object.getPrototypeOf(constructor);\n    }\n    return ancestors.reverse();\n}\nfunction getOwnStaticArrayValues(constructor, propertyName) {\n    const definition = constructor[propertyName];\n    return Array.isArray(definition) ? definition : [];\n}\nfunction getOwnStaticObjectPairs(constructor, propertyName) {\n    const definition = constructor[propertyName];\n    return definition ? Object.keys(definition).map(key => [key, definition[key]]) : [];\n}\n\nfunction bless(constructor) {\n    return shadow(constructor, getBlessedProperties(constructor));\n}\nfunction shadow(constructor, properties) {\n    const shadowConstructor = extend(constructor);\n    const shadowProperties = getShadowProperties(constructor.prototype, properties);\n    Object.defineProperties(shadowConstructor.prototype, shadowProperties);\n    return shadowConstructor;\n}\nfunction getBlessedProperties(constructor) {\n    const blessings = readInheritableStaticArrayValues(constructor, \"blessings\");\n    return blessings.reduce((blessedProperties, blessing) => {\n        const properties = blessing(constructor);\n        for (const key in properties) {\n            const descriptor = blessedProperties[key] || {};\n            blessedProperties[key] = Object.assign(descriptor, properties[key]);\n        }\n        return blessedProperties;\n    }, {});\n}\nfunction getShadowProperties(prototype, properties) {\n    return getOwnKeys(properties).reduce((shadowProperties, key) => {\n        const descriptor = getShadowedDescriptor(prototype, properties, key);\n        if (descriptor) {\n            Object.assign(shadowProperties, { [key]: descriptor });\n        }\n        return shadowProperties;\n    }, {});\n}\nfunction getShadowedDescriptor(prototype, properties, key) {\n    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);\n    const shadowedByValue = shadowingDescriptor && \"value\" in shadowingDescriptor;\n    if (!shadowedByValue) {\n        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;\n        if (shadowingDescriptor) {\n            descriptor.get = shadowingDescriptor.get || descriptor.get;\n            descriptor.set = shadowingDescriptor.set || descriptor.set;\n        }\n        return descriptor;\n    }\n}\nconst getOwnKeys = (() => {\n    if (typeof Object.getOwnPropertySymbols == \"function\") {\n        return (object) => [\n            ...Object.getOwnPropertyNames(object),\n            ...Object.getOwnPropertySymbols(object)\n        ];\n    }\n    else {\n        return Object.getOwnPropertyNames;\n    }\n})();\nconst extend = (() => {\n    function extendWithReflect(constructor) {\n        function extended() {\n            return Reflect.construct(constructor, arguments, new.target);\n        }\n        extended.prototype = Object.create(constructor.prototype, {\n            constructor: { value: extended }\n        });\n        Reflect.setPrototypeOf(extended, constructor);\n        return extended;\n    }\n    function testReflectExtension() {\n        const a = function () { this.a.call(this); };\n        const b = extendWithReflect(a);\n        b.prototype.a = function () { };\n        return new b;\n    }\n    try {\n        testReflectExtension();\n        return extendWithReflect;\n    }\n    catch (error) {\n        return (constructor) => class extended extends constructor {\n        };\n    }\n})();\n\nfunction blessDefinition(definition) {\n    return {\n        identifier: definition.identifier,\n        controllerConstructor: bless(definition.controllerConstructor)\n    };\n}\n\nclass Module {\n    constructor(application, definition) {\n        this.application = application;\n        this.definition = blessDefinition(definition);\n        this.contextsByScope = new WeakMap;\n        this.connectedContexts = new Set;\n    }\n    get identifier() {\n        return this.definition.identifier;\n    }\n    get controllerConstructor() {\n        return this.definition.controllerConstructor;\n    }\n    get contexts() {\n        return Array.from(this.connectedContexts);\n    }\n    connectContextForScope(scope) {\n        const context = this.fetchContextForScope(scope);\n        this.connectedContexts.add(context);\n        context.connect();\n    }\n    disconnectContextForScope(scope) {\n        const context = this.contextsByScope.get(scope);\n        if (context) {\n            this.connectedContexts.delete(context);\n            context.disconnect();\n        }\n    }\n    fetchContextForScope(scope) {\n        let context = this.contextsByScope.get(scope);\n        if (!context) {\n            context = new Context(this, scope);\n            this.contextsByScope.set(scope, context);\n        }\n        return context;\n    }\n}\n\nclass ClassMap {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    has(name) {\n        return this.data.has(this.getDataKey(name));\n    }\n    get(name) {\n        return this.getAll(name)[0];\n    }\n    getAll(name) {\n        const tokenString = this.data.get(this.getDataKey(name)) || \"\";\n        return tokenize(tokenString);\n    }\n    getAttributeName(name) {\n        return this.data.getAttributeNameForKey(this.getDataKey(name));\n    }\n    getDataKey(name) {\n        return `${name}-class`;\n    }\n    get data() {\n        return this.scope.data;\n    }\n}\n\nclass DataMap {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get(key) {\n        const name = this.getAttributeNameForKey(key);\n        return this.element.getAttribute(name);\n    }\n    set(key, value) {\n        const name = this.getAttributeNameForKey(key);\n        this.element.setAttribute(name, value);\n        return this.get(key);\n    }\n    has(key) {\n        const name = this.getAttributeNameForKey(key);\n        return this.element.hasAttribute(name);\n    }\n    delete(key) {\n        if (this.has(key)) {\n            const name = this.getAttributeNameForKey(key);\n            this.element.removeAttribute(name);\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    getAttributeNameForKey(key) {\n        return `data-${this.identifier}-${dasherize(key)}`;\n    }\n}\n\nclass Guide {\n    constructor(logger) {\n        this.warnedKeysByObject = new WeakMap;\n        this.logger = logger;\n    }\n    warn(object, key, message) {\n        let warnedKeys = this.warnedKeysByObject.get(object);\n        if (!warnedKeys) {\n            warnedKeys = new Set;\n            this.warnedKeysByObject.set(object, warnedKeys);\n        }\n        if (!warnedKeys.has(key)) {\n            warnedKeys.add(key);\n            this.logger.warn(message, object);\n        }\n    }\n}\n\nfunction attributeValueContainsToken(attributeName, token) {\n    return `[${attributeName}~=\"${token}\"]`;\n}\n\nclass TargetSet {\n    constructor(scope) {\n        this.scope = scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get schema() {\n        return this.scope.schema;\n    }\n    has(targetName) {\n        return this.find(targetName) != null;\n    }\n    find(...targetNames) {\n        return targetNames.reduce((target, targetName) => target\n            || this.findTarget(targetName)\n            || this.findLegacyTarget(targetName), undefined);\n    }\n    findAll(...targetNames) {\n        return targetNames.reduce((targets, targetName) => [\n            ...targets,\n            ...this.findAllTargets(targetName),\n            ...this.findAllLegacyTargets(targetName)\n        ], []);\n    }\n    findTarget(targetName) {\n        const selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findElement(selector);\n    }\n    findAllTargets(targetName) {\n        const selector = this.getSelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector);\n    }\n    getSelectorForTargetName(targetName) {\n        const attributeName = this.schema.targetAttributeForScope(this.identifier);\n        return attributeValueContainsToken(attributeName, targetName);\n    }\n    findLegacyTarget(targetName) {\n        const selector = this.getLegacySelectorForTargetName(targetName);\n        return this.deprecate(this.scope.findElement(selector), targetName);\n    }\n    findAllLegacyTargets(targetName) {\n        const selector = this.getLegacySelectorForTargetName(targetName);\n        return this.scope.findAllElements(selector).map(element => this.deprecate(element, targetName));\n    }\n    getLegacySelectorForTargetName(targetName) {\n        const targetDescriptor = `${this.identifier}.${targetName}`;\n        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);\n    }\n    deprecate(element, targetName) {\n        if (element) {\n            const { identifier } = this;\n            const attributeName = this.schema.targetAttribute;\n            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);\n            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}=\"${identifier}.${targetName}\" with ${revisedAttributeName}=\"${targetName}\". ` +\n                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);\n        }\n        return element;\n    }\n    get guide() {\n        return this.scope.guide;\n    }\n}\n\nclass Scope {\n    constructor(schema, element, identifier, logger) {\n        this.targets = new TargetSet(this);\n        this.classes = new ClassMap(this);\n        this.data = new DataMap(this);\n        this.containsElement = (element) => {\n            return element.closest(this.controllerSelector) === this.element;\n        };\n        this.schema = schema;\n        this.element = element;\n        this.identifier = identifier;\n        this.guide = new Guide(logger);\n    }\n    findElement(selector) {\n        return this.element.matches(selector)\n            ? this.element\n            : this.queryElements(selector).find(this.containsElement);\n    }\n    findAllElements(selector) {\n        return [\n            ...this.element.matches(selector) ? [this.element] : [],\n            ...this.queryElements(selector).filter(this.containsElement)\n        ];\n    }\n    queryElements(selector) {\n        return Array.from(this.element.querySelectorAll(selector));\n    }\n    get controllerSelector() {\n        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);\n    }\n}\n\nclass ScopeObserver {\n    constructor(element, schema, delegate) {\n        this.element = element;\n        this.schema = schema;\n        this.delegate = delegate;\n        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);\n        this.scopesByIdentifierByElement = new WeakMap;\n        this.scopeReferenceCounts = new WeakMap;\n    }\n    start() {\n        this.valueListObserver.start();\n    }\n    stop() {\n        this.valueListObserver.stop();\n    }\n    get controllerAttribute() {\n        return this.schema.controllerAttribute;\n    }\n    parseValueForToken(token) {\n        const { element, content: identifier } = token;\n        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);\n        let scope = scopesByIdentifier.get(identifier);\n        if (!scope) {\n            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);\n            scopesByIdentifier.set(identifier, scope);\n        }\n        return scope;\n    }\n    elementMatchedValue(element, value) {\n        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;\n        this.scopeReferenceCounts.set(value, referenceCount);\n        if (referenceCount == 1) {\n            this.delegate.scopeConnected(value);\n        }\n    }\n    elementUnmatchedValue(element, value) {\n        const referenceCount = this.scopeReferenceCounts.get(value);\n        if (referenceCount) {\n            this.scopeReferenceCounts.set(value, referenceCount - 1);\n            if (referenceCount == 1) {\n                this.delegate.scopeDisconnected(value);\n            }\n        }\n    }\n    fetchScopesByIdentifierForElement(element) {\n        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);\n        if (!scopesByIdentifier) {\n            scopesByIdentifier = new Map;\n            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);\n        }\n        return scopesByIdentifier;\n    }\n}\n\nclass Router {\n    constructor(application) {\n        this.application = application;\n        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);\n        this.scopesByIdentifier = new Multimap;\n        this.modulesByIdentifier = new Map;\n    }\n    get element() {\n        return this.application.element;\n    }\n    get schema() {\n        return this.application.schema;\n    }\n    get logger() {\n        return this.application.logger;\n    }\n    get controllerAttribute() {\n        return this.schema.controllerAttribute;\n    }\n    get modules() {\n        return Array.from(this.modulesByIdentifier.values());\n    }\n    get contexts() {\n        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);\n    }\n    start() {\n        this.scopeObserver.start();\n    }\n    stop() {\n        this.scopeObserver.stop();\n    }\n    loadDefinition(definition) {\n        this.unloadIdentifier(definition.identifier);\n        const module = new Module(this.application, definition);\n        this.connectModule(module);\n    }\n    unloadIdentifier(identifier) {\n        const module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            this.disconnectModule(module);\n        }\n    }\n    getContextForElementAndIdentifier(element, identifier) {\n        const module = this.modulesByIdentifier.get(identifier);\n        if (module) {\n            return module.contexts.find(context => context.element == element);\n        }\n    }\n    handleError(error, message, detail) {\n        this.application.handleError(error, message, detail);\n    }\n    createScopeForElementAndIdentifier(element, identifier) {\n        return new Scope(this.schema, element, identifier, this.logger);\n    }\n    scopeConnected(scope) {\n        this.scopesByIdentifier.add(scope.identifier, scope);\n        const module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.connectContextForScope(scope);\n        }\n    }\n    scopeDisconnected(scope) {\n        this.scopesByIdentifier.delete(scope.identifier, scope);\n        const module = this.modulesByIdentifier.get(scope.identifier);\n        if (module) {\n            module.disconnectContextForScope(scope);\n        }\n    }\n    connectModule(module) {\n        this.modulesByIdentifier.set(module.identifier, module);\n        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach(scope => module.connectContextForScope(scope));\n    }\n    disconnectModule(module) {\n        this.modulesByIdentifier.delete(module.identifier);\n        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);\n        scopes.forEach(scope => module.disconnectContextForScope(scope));\n    }\n}\n\nconst defaultSchema = {\n    controllerAttribute: \"data-controller\",\n    actionAttribute: \"data-action\",\n    targetAttribute: \"data-target\",\n    targetAttributeForScope: identifier => `data-${identifier}-target`\n};\n\nclass Application {\n    constructor(element = document.documentElement, schema = defaultSchema) {\n        this.logger = console;\n        this.debug = false;\n        this.logDebugActivity = (identifier, functionName, detail = {}) => {\n            if (this.debug) {\n                this.logFormattedMessage(identifier, functionName, detail);\n            }\n        };\n        this.element = element;\n        this.schema = schema;\n        this.dispatcher = new Dispatcher(this);\n        this.router = new Router(this);\n    }\n    static start(element, schema) {\n        const application = new Application(element, schema);\n        application.start();\n        return application;\n    }\n    async start() {\n        await domReady();\n        this.logDebugActivity(\"application\", \"starting\");\n        this.dispatcher.start();\n        this.router.start();\n        this.logDebugActivity(\"application\", \"start\");\n    }\n    stop() {\n        this.logDebugActivity(\"application\", \"stopping\");\n        this.dispatcher.stop();\n        this.router.stop();\n        this.logDebugActivity(\"application\", \"stop\");\n    }\n    register(identifier, controllerConstructor) {\n        if (controllerConstructor.shouldLoad) {\n            this.load({ identifier, controllerConstructor });\n        }\n    }\n    load(head, ...rest) {\n        const definitions = Array.isArray(head) ? head : [head, ...rest];\n        definitions.forEach(definition => this.router.loadDefinition(definition));\n    }\n    unload(head, ...rest) {\n        const identifiers = Array.isArray(head) ? head : [head, ...rest];\n        identifiers.forEach(identifier => this.router.unloadIdentifier(identifier));\n    }\n    get controllers() {\n        return this.router.contexts.map(context => context.controller);\n    }\n    getControllerForElementAndIdentifier(element, identifier) {\n        const context = this.router.getContextForElementAndIdentifier(element, identifier);\n        return context ? context.controller : null;\n    }\n    handleError(error, message, detail) {\n        var _a;\n        this.logger.error(`%s\\n\\n%o\\n\\n%o`, message, error, detail);\n        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, \"\", 0, 0, error);\n    }\n    logFormattedMessage(identifier, functionName, detail = {}) {\n        detail = Object.assign({ application: this }, detail);\n        this.logger.groupCollapsed(`${identifier} #${functionName}`);\n        this.logger.log(\"details:\", Object.assign({}, detail));\n        this.logger.groupEnd();\n    }\n}\nfunction domReady() {\n    return new Promise(resolve => {\n        if (document.readyState == \"loading\") {\n            document.addEventListener(\"DOMContentLoaded\", () => resolve());\n        }\n        else {\n            resolve();\n        }\n    });\n}\n\nfunction ClassPropertiesBlessing(constructor) {\n    const classes = readInheritableStaticArrayValues(constructor, \"classes\");\n    return classes.reduce((properties, classDefinition) => {\n        return Object.assign(properties, propertiesForClassDefinition(classDefinition));\n    }, {});\n}\nfunction propertiesForClassDefinition(key) {\n    return {\n        [`${key}Class`]: {\n            get() {\n                const { classes } = this;\n                if (classes.has(key)) {\n                    return classes.get(key);\n                }\n                else {\n                    const attribute = classes.getAttributeName(key);\n                    throw new Error(`Missing attribute \"${attribute}\"`);\n                }\n            }\n        },\n        [`${key}Classes`]: {\n            get() {\n                return this.classes.getAll(key);\n            }\n        },\n        [`has${capitalize(key)}Class`]: {\n            get() {\n                return this.classes.has(key);\n            }\n        }\n    };\n}\n\nfunction TargetPropertiesBlessing(constructor) {\n    const targets = readInheritableStaticArrayValues(constructor, \"targets\");\n    return targets.reduce((properties, targetDefinition) => {\n        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));\n    }, {});\n}\nfunction propertiesForTargetDefinition(name) {\n    return {\n        [`${name}Target`]: {\n            get() {\n                const target = this.targets.find(name);\n                if (target) {\n                    return target;\n                }\n                else {\n                    throw new Error(`Missing target element \"${name}\" for \"${this.identifier}\" controller`);\n                }\n            }\n        },\n        [`${name}Targets`]: {\n            get() {\n                return this.targets.findAll(name);\n            }\n        },\n        [`has${capitalize(name)}Target`]: {\n            get() {\n                return this.targets.has(name);\n            }\n        }\n    };\n}\n\nfunction ValuePropertiesBlessing(constructor) {\n    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, \"values\");\n    const propertyDescriptorMap = {\n        valueDescriptorMap: {\n            get() {\n                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {\n                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair);\n                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);\n                    return Object.assign(result, { [attributeName]: valueDescriptor });\n                }, {});\n            }\n        }\n    };\n    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {\n        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));\n    }, propertyDescriptorMap);\n}\nfunction propertiesForValueDefinitionPair(valueDefinitionPair) {\n    const definition = parseValueDefinitionPair(valueDefinitionPair);\n    const { key, name, reader: read, writer: write } = definition;\n    return {\n        [name]: {\n            get() {\n                const value = this.data.get(key);\n                if (value !== null) {\n                    return read(value);\n                }\n                else {\n                    return definition.defaultValue;\n                }\n            },\n            set(value) {\n                if (value === undefined) {\n                    this.data.delete(key);\n                }\n                else {\n                    this.data.set(key, write(value));\n                }\n            }\n        },\n        [`has${capitalize(name)}`]: {\n            get() {\n                return this.data.has(key) || definition.hasCustomDefaultValue;\n            }\n        }\n    };\n}\nfunction parseValueDefinitionPair([token, typeDefinition]) {\n    return valueDescriptorForTokenAndTypeDefinition(token, typeDefinition);\n}\nfunction parseValueTypeConstant(constant) {\n    switch (constant) {\n        case Array: return \"array\";\n        case Boolean: return \"boolean\";\n        case Number: return \"number\";\n        case Object: return \"object\";\n        case String: return \"string\";\n    }\n}\nfunction parseValueTypeDefault(defaultValue) {\n    switch (typeof defaultValue) {\n        case \"boolean\": return \"boolean\";\n        case \"number\": return \"number\";\n        case \"string\": return \"string\";\n    }\n    if (Array.isArray(defaultValue))\n        return \"array\";\n    if (Object.prototype.toString.call(defaultValue) === \"[object Object]\")\n        return \"object\";\n}\nfunction parseValueTypeObject(typeObject) {\n    const typeFromObject = parseValueTypeConstant(typeObject.type);\n    if (typeFromObject) {\n        const defaultValueType = parseValueTypeDefault(typeObject.default);\n        if (typeFromObject !== defaultValueType) {\n            throw new Error(`Type \"${typeFromObject}\" must match the type of the default value. Given default value: \"${typeObject.default}\" as \"${defaultValueType}\"`);\n        }\n        return typeFromObject;\n    }\n}\nfunction parseValueTypeDefinition(typeDefinition) {\n    const typeFromObject = parseValueTypeObject(typeDefinition);\n    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);\n    const typeFromConstant = parseValueTypeConstant(typeDefinition);\n    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;\n    if (type)\n        return type;\n    throw new Error(`Unknown value type \"${typeDefinition}\"`);\n}\nfunction defaultValueForDefinition(typeDefinition) {\n    const constant = parseValueTypeConstant(typeDefinition);\n    if (constant)\n        return defaultValuesByType[constant];\n    const defaultValue = typeDefinition.default;\n    if (defaultValue !== undefined)\n        return defaultValue;\n    return typeDefinition;\n}\nfunction valueDescriptorForTokenAndTypeDefinition(token, typeDefinition) {\n    const key = `${dasherize(token)}-value`;\n    const type = parseValueTypeDefinition(typeDefinition);\n    return {\n        type,\n        key,\n        name: camelize(key),\n        get defaultValue() { return defaultValueForDefinition(typeDefinition); },\n        get hasCustomDefaultValue() { return parseValueTypeDefault(typeDefinition) !== undefined; },\n        reader: readers[type],\n        writer: writers[type] || writers.default\n    };\n}\nconst defaultValuesByType = {\n    get array() { return []; },\n    boolean: false,\n    number: 0,\n    get object() { return {}; },\n    string: \"\"\n};\nconst readers = {\n    array(value) {\n        const array = JSON.parse(value);\n        if (!Array.isArray(array)) {\n            throw new TypeError(\"Expected array\");\n        }\n        return array;\n    },\n    boolean(value) {\n        return !(value == \"0\" || value == \"false\");\n    },\n    number(value) {\n        return Number(value);\n    },\n    object(value) {\n        const object = JSON.parse(value);\n        if (object === null || typeof object != \"object\" || Array.isArray(object)) {\n            throw new TypeError(\"Expected object\");\n        }\n        return object;\n    },\n    string(value) {\n        return value;\n    }\n};\nconst writers = {\n    default: writeString,\n    array: writeJSON,\n    object: writeJSON\n};\nfunction writeJSON(value) {\n    return JSON.stringify(value);\n}\nfunction writeString(value) {\n    return `${value}`;\n}\n\nclass Controller {\n    constructor(context) {\n        this.context = context;\n    }\n    static get shouldLoad() {\n        return true;\n    }\n    get application() {\n        return this.context.application;\n    }\n    get scope() {\n        return this.context.scope;\n    }\n    get element() {\n        return this.scope.element;\n    }\n    get identifier() {\n        return this.scope.identifier;\n    }\n    get targets() {\n        return this.scope.targets;\n    }\n    get classes() {\n        return this.scope.classes;\n    }\n    get data() {\n        return this.scope.data;\n    }\n    initialize() {\n    }\n    connect() {\n    }\n    disconnect() {\n    }\n    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {\n        const type = prefix ? `${prefix}:${eventName}` : eventName;\n        const event = new CustomEvent(type, { detail, bubbles, cancelable });\n        target.dispatchEvent(event);\n        return event;\n    }\n}\nController.blessings = [ClassPropertiesBlessing, TargetPropertiesBlessing, ValuePropertiesBlessing];\nController.targets = [];\nController.values = {};\n\nexport { Application, AttributeObserver, Context, Controller, ElementObserver, IndexedMultimap, Multimap, StringMapObserver, TokenListObserver, ValueListObserver, add, defaultSchema, del, fetch, prune };\n","var map = {\n\t\"./clipboard_controller.js\": 2,\n\t\"./example_controller.js\": 3,\n\t\"./menu_controller.js\": 4\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 1;","// src/controllers/clipboard_controller.js\nimport { Controller } from \"@hotwired/stimulus\";\n\nexport default class extends Controller {\n  static targets = [\"source\"];\n  copy() {\n    navigator.clipboard.writeText(this.sourceTarget.value);\n  }\n}","import { Controller } from \"@hotwired/stimulus\"\n\nexport default class extends Controller {\n  connect() {\n    this.element.textContent = \"Yeah it works!\"\n  }\n}\n","import { Controller } from \"@hotwired/stimulus\";\n\nexport default class extends Controller {\n  static targets = [\"toggleable\"];\n\n  toggle() {\n    this.toggleableTarget.classList.toggle(\"hidden\");\n  }\n}\n","import { Application } from \"@hotwired/stimulus\"\nimport { definitionsFromContext } from \"@hotwired/stimulus-webpack-helpers\"\n\nconst application = Application.start()\nconst context = require.context(\"./controllers\", true, /\\.js$/)\napplication.load(definitionsFromContext(context))","/*\nStimulus Webpack Helpers 1.0.0\nCopyright Â© 2021 Basecamp, LLC\n */\nfunction definitionsFromContext(context) {\n    return context.keys()\n        .map((key) => definitionForModuleWithContextAndKey(context, key))\n        .filter((value) => value);\n}\nfunction definitionForModuleWithContextAndKey(context, key) {\n    const identifier = identifierForContextKey(key);\n    if (identifier) {\n        return definitionForModuleAndIdentifier(context(key), identifier);\n    }\n}\nfunction definitionForModuleAndIdentifier(module, identifier) {\n    const controllerConstructor = module.default;\n    if (typeof controllerConstructor == \"function\") {\n        return { identifier, controllerConstructor };\n    }\n}\nfunction identifierForContextKey(key) {\n    const logicalName = (key.match(/^(?:\\.\\/)?(.+)(?:[_-]controller\\..+?)$/) || [])[1];\n    if (logicalName) {\n        return logicalName.replace(/_/g, \"-\").replace(/\\//g, \"--\");\n    }\n}\n\nexport { definitionForModuleAndIdentifier, definitionForModuleWithContextAndKey, definitionsFromContext, identifierForContextKey };\n"],"sourceRoot":""}